<!DOCTYPE html>
<html>

<head>
    <title>Ball Tag</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Exo+2:wght@400;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --reef-bg-top: #173b78;
            --reef-bg-bottom: #1f4f94;
            --reef-glow: rgba(140, 230, 255, 0.25);
            --hud-bg: rgba(10, 26, 61, 0.85);
            --hud-text: #e8f7ff;
            --accent-cyan: #00f0ff;
            --accent-gold: #ffd700;
            --accent-blue: #1e90ff;
        }

        body {
            margin: 0;
            overflow: hidden;
            position: relative;
            height: 100vh;
            background: linear-gradient(180deg, var(--reef-bg-top) 0%, var(--reef-bg-bottom) 100%);
            font-family: 'Exo 2', sans-serif;
            color: white;
        }

        /* Animated Background */
        body::before {
            content: "";
            position: absolute;
            inset: 0;
            background:
                radial-gradient(900px 700px at 20% 30%, var(--reef-glow), transparent 60%),
                radial-gradient(700px 500px at 75% 20%, rgba(255, 180, 220, 0.18), transparent 60%),
                radial-gradient(1000px 800px at 50% 80%, rgba(0, 200, 255, 0.2), transparent 65%);
            pointer-events: none;
            z-index: 0;
            animation: breathe 8s ease-in-out infinite alternate;
        }

        @keyframes breathe {
            0% {
                opacity: 0.8;
                transform: scale(1);
            }

            100% {
                opacity: 1;
                transform: scale(1.02);
            }
        }

        /* Floating Particles */
        .particle {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            animation: floatUp linear infinite;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(100vh) scale(0);
                opacity: 0;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                transform: translateY(-10vh) scale(1);
                opacity: 0;
            }
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #hud {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .hud-item {
            background: var(--hud-bg);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(0, 240, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            backdrop-filter: blur(4px);
        }

        .hud-icon {
            font-size: 16px;
        }

        /* Modal / Menu Styles */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(5, 10, 25, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: rgba(15, 30, 60, 0.95);
            border: 1px solid var(--accent-cyan);
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.15);
            max-width: 500px;
            width: 90%;
            position: relative;
        }

        .game-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 42px;
            color: var(--accent-cyan);
            text-shadow: 0 0 20px rgba(0, 240, 255, 0.5);
            margin: 0 0 10px 0;
        }

        .subtitle {
            color: #8ce6ff;
            font-size: 18px;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        .guide-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 30px;
            text-align: center;
        }

        .guide-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .guide-icon {
            font-size: 24px;
            margin-bottom: 8px;
            display: block;
        }

        .guide-text {
            font-size: 12px;
            color: #ccc;
        }

        .difficulty-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .btn {
            background: transparent;
            border: 1px solid var(--accent-cyan);
            color: var(--accent-cyan);
            padding: 12px 24px;
            border-radius: 8px;
            font-family: 'Exo 2', sans-serif;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            background: var(--accent-cyan);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.4);
        }

        .btn-primary {
            background: rgba(0, 240, 255, 0.15);
        }

        /* Game Over Specifics */
        #game-over-stats {
            font-size: 24px;
            margin: 20px 0;
            color: #fff;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.3);
            margin: 5px 0;
            border-radius: 6px;
            font-size: 16px;
        }

        /* Countdown */
        #countdown-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 120px;
            color: #fff;
            text-shadow: 0 0 30px var(--accent-cyan);
            z-index: 50;
            pointer-events: none;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>
    <!-- HUD -->
    <div id="hud" class="hidden">
        <div class="hud-item">
            <span class="hud-icon">‚è±Ô∏è</span> <span id="time-remaining">10</span>s
        </div>
        <div class="hud-item">
            <span class="hud-icon">‚ö´</span> <span id="ball-count">1</span>
        </div>
        <div class="hud-item">
            <span class="hud-icon">üìä</span> <span id="difficulty-label">Easy</span>
        </div>
        <div class="hud-item">
            <span class="hud-icon">‚ö°</span> <span id="status-text">Playing</span>
        </div>
    </div>

    <!-- Game Elements Container -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- Start / Pause Menu Modal -->
    <div id="main-menu" class="modal-overlay visible">
        <div class="modal-content">
            <h1 class="game-title">BALL TAG</h1>
            <div class="subtitle">Survive the deep. Dodge the dark.</div>

            <div class="guide-grid">
                <div class="guide-item">
                    <span class="guide-icon">‚å®Ô∏è</span>
                    <span class="guide-text">Arrow Keys to Move</span>
                </div>
                <div class="guide-item">
                    <span class="guide-icon">‚ê£</span>
                    <span class="guide-text">Space to Clone</span>
                </div>
                <div class="guide-item">
                    <span class="guide-icon">‚ö°</span>
                    <span class="guide-text">Collect Power-ups</span>
                </div>
            </div>

            <h3 style="color: var(--accent-cyan); margin-bottom: 15px;">SELECT DIFFICULTY</h3>
            <div class="difficulty-buttons">
                <button class="btn" onclick="startGame('easy')">Easy</button>
                <button class="btn" onclick="startGame('medium')">Medium</button>
                <button class="btn" onclick="startGame('hard')">Hard</button>
            </div>

            <div id="resume-container" class="hidden"
                style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 20px;">
                <button class="btn btn-primary" onclick="resumeGame()">Resume Game</button>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal-overlay">
        <div class="modal-content">
            <h1 class="game-title" style="color: #ff4d4d; text-shadow: 0 0 20px rgba(255, 77, 77, 0.5);">GAME OVER</h1>

            <div id="game-over-stats">
                <div class="stat-row">
                    <span>Rounds Survived:</span>
                    <span id="final-rounds" style="color: var(--accent-cyan)">0</span>
                </div>
                <div class="stat-row">
                    <span>Difficulty:</span>
                    <span id="final-difficulty" style="color: var(--accent-gold)">Easy</span>
                </div>
            </div>

            <div class="difficulty-buttons">
                <button class="btn btn-primary" onclick="showMainMenu()">Main Menu</button>
                <button class="btn" onclick="restartGame()">Try Again</button>
            </div>
        </div>
    </div>

    <div id="countdown-overlay">3</div>

    <script>
        // Expose functions to global scope for HTML buttons
        window.startGame = null;
        window.resumeGame = null;
        window.restartGame = null;
        window.showMainMenu = null;

        (function () {
            const canvas = document.getElementById("game-canvas");
            const ctx = canvas.getContext("2d", { alpha: true });

            const timeRemainingEl = document.getElementById("time-remaining");
            const ballCountEl = document.getElementById("ball-count");
            const statusText = document.getElementById("status-text");
            const difficultyLabel = document.getElementById("difficulty-label");
            const countdownOverlay = document.getElementById("countdown-overlay");

            // New UI Elements
            const hud = document.getElementById("hud");
            const gameContainer = document.getElementById("game-container");
            const mainMenu = document.getElementById("main-menu");
            const gameOverModal = document.getElementById("game-over-modal");
            const resumeContainer = document.getElementById("resume-container");
            const finalRoundsEl = document.getElementById("final-rounds");
            const finalDifficultyEl = document.getElementById("final-difficulty");
            const gameTitle = document.querySelector(".game-title");

            // Update Title
            gameTitle.textContent = "BALL TAG";
            document.title = "Ball Tag";

            // Tunable global settings
            const ROUND_TIME_SECONDS = 5;
            const NEW_PLAYER_EVERY_ROUNDS = 2;
            const PLAYER_SPEED_START = 6; // Increased from 4
            const PLAYER_SPEED_PER_ROUND = 0.33;
            const PLAYER_SMOOTHING = 0.2;
            const BLACK_BALL_SPEED_START = 3; // Increased from 1.5
            const BLACK_BALL_SPEED_INCREMENT = 0.3;
            const PLAY_AREA_PADDING = 10;
            const AUTOPILOT_DIR_CHANGE_MIN_MS = 800;
            const AUTOPILOT_DIR_CHANGE_MAX_MS = 1600;
            const AUTOPILOT_AVOID_WEIGHT = 1.2;
            const ACTIVE_AVOID_WEIGHT = 0.6;
            const SPEED_BOOST_AMOUNT = 1;
            const POWERUP_DURATION_MS = 2000;
            const POWERUP_SPAWN_ROUND = 3;
            const POWERUP_RADIUS = 20; // 40px width / 2
            const BALL_RADIUS = 8; // 16px width / 2
            const POWERUP_SPAWN_DELAY_MIN_MS = 600;
            const POWERUP_SPAWN_DELAY_MAX_MS = 2600;
            const BLACK_SPAWN_INSET = 50;
            const SPEED_RAMP_MAX_ROUND = 15;
            const MAX_PLAYERS = 15;
            const DIFFICULTIES = {
                easy: {
                    label: "Easy",
                    startBalls: 1,
                    playerSpeedDelta: 0,
                    enemySpeedDelta: 0,
                },
                medium: {
                    label: "Medium",
                    startBalls: 4,
                    playerSpeedDelta: 0,
                    enemySpeedDelta: 0,
                },
                hard: {
                    label: "Hard",
                    startBalls: 5,
                    playerSpeedDelta: 0.2,
                    enemySpeedDelta: 1.5, // Increased from 0.2
                },
            };

            // Game state
            let blackBalls = [];
            let powerups = [];
            let ballCount = 1;
            let timer = ROUND_TIME_SECONDS;
            let timerInterval = null;
            let isGameOver = false;
            let isPaused = false;
            let roundsSurvived = 0;
            let speedBoostUntil = 0;
            let speedBoostHolder = null;
            let invincibleUntil = 0;
            let powerupSpawnTimeout = null;
            let playerSpeedDelta = 0;
            let enemySpeedDelta = 0;
            let currentDifficulty = "easy";
            let isCountingDown = false;
            let audioCtx = null;
            let gameStarted = false;

            const players = [];
            let activeIndex = 0;

            // Resize handling
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // Clamp positions after resize
                players.forEach(p => clampEntity(p));
                blackBalls.forEach(b => clampEntity(b));
                powerups.forEach(p => clampEntity(p));
            }
            window.addEventListener("resize", resizeCanvas);
            resizeCanvas();

            // --- Core Helper Functions ---

            function clamp(value, min, max) {
                return Math.min(max, Math.max(min, value));
            }

            function clampEntity(entity) {
                const r = entity.radius || BALL_RADIUS;
                entity.x = clamp(entity.x, PLAY_AREA_PADDING, canvas.width - r * 2 - PLAY_AREA_PADDING);
                entity.y = clamp(entity.y, PLAY_AREA_PADDING, canvas.height - r * 2 - PLAY_AREA_PADDING);
            }

            function randBetween(min, max) {
                return Math.random() * (max - min) + min;
            }

            function randomUnitVector() {
                const angle = Math.random() * Math.PI * 2;
                return { x: Math.cos(angle), y: Math.sin(angle) };
            }

            // --- Player & Entity Management ---

            function createPlayer() {
                const player = {
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    radius: BALL_RADIUS,
                    inputX: 0,
                    inputY: 0,
                    isActive: false,
                    autoDirX: 0,
                    autoDirY: 0,
                    autoDirChangeAt: 0,
                    color: '#ff3030',
                    glowColor: 'rgba(255, 48, 48, 0.6)'
                };
                setRandomAutoDir(player);
                return player;
            }

            function spawnExtraPlayer() {
                if (isGameOver || isPaused || !gameStarted || players.length >= MAX_PLAYERS) return;
                const reference = players[activeIndex] || players[0];
                const p = createPlayer();
                if (reference) {
                    p.x = clamp(reference.x + 16, PLAY_AREA_PADDING, canvas.width - p.radius * 2 - PLAY_AREA_PADDING);
                    p.y = clamp(reference.y + 16, PLAY_AREA_PADDING, canvas.height - p.radius * 2 - PLAY_AREA_PADDING);
                } else {
                    p.x = (canvas.width / 2) - p.radius;
                    p.y = (canvas.height / 2) - p.radius;
                }
                p.vx = 0;
                p.vy = 0;
                setRandomAutoDir(p);
                players.push(p);
                setActivePlayer(activeIndex);
            }

            function positionPlayersAtCenter() {
                const startX = (canvas.width / 2);
                const startY = (canvas.height / 2);
                players.forEach((p, idx) => {
                    const offset = (idx - activeIndex) * 20;
                    p.x = startX + offset - p.radius;
                    p.y = startY + offset - p.radius;
                    p.vx = 0;
                    p.vy = 0;
                    setRandomAutoDir(p);
                });
            }

            function setRandomAutoDir(player) {
                const dir = randomUnitVector();
                player.autoDirX = dir.x;
                player.autoDirY = dir.y;
                const span = AUTOPILOT_DIR_CHANGE_MAX_MS - AUTOPILOT_DIR_CHANGE_MIN_MS;
                player.autoDirChangeAt = Date.now() + AUTOPILOT_DIR_CHANGE_MIN_MS + Math.random() * span;
            }

            function randomSpawnPosition(width = 14, height = 14) {
                const x = Math.random() * (canvas.width - PLAY_AREA_PADDING * 2 - width) + PLAY_AREA_PADDING;
                const y = Math.random() * (canvas.height - PLAY_AREA_PADDING * 2 - height) + PLAY_AREA_PADDING;
                return { x, y };
            }

            function spawnBlackBalls(count) {
                blackBalls = [];
                for (let i = 0; i < count; i++) {
                    let pos;
                    const r = BALL_RADIUS;
                    // Spawn logic (corners/sides)
                    if (i < 4) {
                        // Corners
                        const minX = PLAY_AREA_PADDING, maxX = canvas.width - PLAY_AREA_PADDING - r * 2;
                        const minY = PLAY_AREA_PADDING, maxY = canvas.height - PLAY_AREA_PADDING - r * 2;
                        const inset = BLACK_SPAWN_INSET;
                        const corners = [
                            { x: randBetween(minX, Math.min(minX + inset, maxX)), y: randBetween(minY, Math.min(minY + inset, maxY)) },
                            { x: randBetween(Math.max(maxX - inset, minX), maxX), y: randBetween(minY, Math.min(minY + inset, maxY)) },
                            { x: randBetween(Math.max(maxX - inset, minX), maxX), y: randBetween(Math.max(maxY - inset, minY), maxY) },
                            { x: randBetween(minX, Math.min(minX + inset, maxX)), y: randBetween(Math.max(maxY - inset, minY), maxY) }
                        ];
                        pos = corners[i % 4];
                    } else {
                        // Sides
                        const minX = PLAY_AREA_PADDING, maxX = canvas.width - PLAY_AREA_PADDING - r * 2;
                        const minY = PLAY_AREA_PADDING, maxY = canvas.height - PLAY_AREA_PADDING - r * 2;
                        const inset = BLACK_SPAWN_INSET;
                        const sides = [
                            { x: randBetween(Math.min(maxX - inset, minX + inset), Math.max(minX + inset, maxX - inset)), y: randBetween(minY, Math.min(minY + inset, maxY)) },
                            { x: randBetween(Math.max(maxX - inset, minX), maxX), y: randBetween(Math.min(maxY - inset, minY), Math.max(minY + inset, maxY - inset)) },
                            { x: randBetween(Math.min(maxX - inset, minX + inset), Math.max(minX + inset, maxX - inset)), y: randBetween(Math.max(maxY - inset, minY), maxY) },
                            { x: randBetween(minX, Math.min(minX + inset, maxX)), y: randBetween(Math.min(maxY - inset, minY + inset), Math.max(minY + inset, maxY - inset)) }
                        ];
                        pos = sides[(i - 4) % 4];
                    }

                    blackBalls.push({
                        x: pos.x,
                        y: pos.y,
                        radius: BALL_RADIUS,
                        color: '#0b101c',
                        glowColor: 'rgba(0, 240, 255, 0.45)'
                    });
                }
            }

            function checkCollision(c1, c2) {
                // Simple AABB for now since we use top-left coords, but let's do circle-circle
                // Convert top-left to center
                const c1x = c1.x + c1.radius;
                const c1y = c1.y + c1.radius;
                const c2x = c2.x + c2.radius;
                const c2y = c2.y + c2.radius;

                const dx = c1x - c2x;
                const dy = c1y - c2y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                return dist < (c1.radius + c2.radius);
            }

            // --- Power-ups ---

            function clearPowerups() {
                powerups = [];
            }

            function clearPowerupTimer() {
                if (powerupSpawnTimeout) {
                    clearTimeout(powerupSpawnTimeout);
                    powerupSpawnTimeout = null;
                }
            }

            function spawnSinglePowerup() {
                clearPowerups();
                powerupSpawnTimeout = null;
                const isSpeed = Math.random() < 0.5;
                const pos = randomSpawnPosition(POWERUP_RADIUS * 2, POWERUP_RADIUS * 2);

                powerups.push({
                    x: pos.x,
                    y: pos.y,
                    radius: POWERUP_RADIUS,
                    type: isSpeed ? 'speed' : 'invincible',
                    icon: isSpeed ? "‚ö°" : "üõ°Ô∏è",
                    color: isSpeed ? '#1e90ff' : '#ffd700',
                    pulsePhase: 0
                });
            }

            function spawnPowerupsForRound() {
                clearPowerups();
                clearPowerupTimer();
                const currentRound = roundsSurvived + 1;
                if (currentRound < POWERUP_SPAWN_ROUND) return;
                const delay = POWERUP_SPAWN_DELAY_MIN_MS + Math.random() * (POWERUP_SPAWN_DELAY_MAX_MS - POWERUP_SPAWN_DELAY_MIN_MS);
                powerupSpawnTimeout = setTimeout(spawnSinglePowerup, delay);
            }

            function applySpeedBoost(holderIdx) {
                speedBoostUntil = Date.now() + POWERUP_DURATION_MS;
                speedBoostHolder = holderIdx;
                clearPowerups();
                statusText.textContent = "Speed Boost!";
            }

            function applyInvincibility() {
                invincibleUntil = Date.now() + POWERUP_DURATION_MS;
                clearPowerups();
                statusText.textContent = "Invincible!";
            }

            function checkPowerupPickup() {
                players.forEach((p, idx) => {
                    powerups.forEach(pow => {
                        if (checkCollision(p, pow)) {
                            if (pow.type === 'speed') applySpeedBoost(idx);
                            else applyInvincibility();
                        }
                    });
                });
            }

            // --- Input Handling ---

            const keysPressed = new Set();

            function updateActiveInputFromKeys(player) {
                player.inputX = 0;
                player.inputY = 0;
                if (keysPressed.has("ArrowLeft")) player.inputX -= 1;
                if (keysPressed.has("ArrowRight")) player.inputX += 1;
                if (keysPressed.has("ArrowUp")) player.inputY -= 1;
                if (keysPressed.has("ArrowDown")) player.inputY += 1;

                if (player.inputX !== 0 || player.inputY !== 0) {
                    const len = Math.hypot(player.inputX, player.inputY);
                    player.inputX /= len;
                    player.inputY /= len;
                }
            }

            document.addEventListener("keydown", (event) => {
                if (isGameOver || !gameStarted) return;

                if (event.code === "Escape") {
                    togglePause();
                    return;
                }

                if (isPaused) return;

                if (event.code === "Space") {
                    event.preventDefault();
                    spawnExtraPlayer();
                    return;
                }
                if (["ArrowDown", "ArrowUp", "ArrowRight", "ArrowLeft"].includes(event.key)) {
                    keysPressed.add(event.key);
                    const active = players[activeIndex];
                    if (active) updateActiveInputFromKeys(active);
                }
            });

            document.addEventListener("keyup", (event) => {
                if (["ArrowDown", "ArrowUp", "ArrowRight", "ArrowLeft"].includes(event.key)) {
                    keysPressed.delete(event.key);
                    const active = players[activeIndex];
                    if (active) updateActiveInputFromKeys(active);
                }
            });

            // --- Game Logic ---

            function avoidanceInput(player) {
                if (blackBalls.length === 0) return { x: 0, y: 0 };
                let nearest = null;
                let nearestDist = Infinity;
                blackBalls.forEach(ball => {
                    const dx = player.x - ball.x;
                    const dy = player.y - ball.y;
                    const d = Math.hypot(dx, dy);
                    if (d < nearestDist) {
                        nearestDist = d;
                        nearest = { dx, dy };
                    }
                });
                if (!nearest || nearestDist === 0) return { x: 0, y: 0 };
                const len = Math.hypot(nearest.dx, nearest.dy);
                return { x: nearest.dx / len, y: nearest.dy / len };
            }

            function updatePlayer(player, isActive, idx) {
                let desiredX = 0, desiredY = 0;
                const avoid = avoidanceInput(player);

                if (isActive) {
                    updateActiveInputFromKeys(player);
                    const magInput = Math.hypot(player.inputX, player.inputY);
                    if (magInput > 0) {
                        desiredX = player.inputX + avoid.x * ACTIVE_AVOID_WEIGHT;
                        desiredY = player.inputY + avoid.y * ACTIVE_AVOID_WEIGHT;
                    }
                } else {
                    if (Date.now() > player.autoDirChangeAt) setRandomAutoDir(player);
                    desiredX = player.autoDirX + avoid.x * AUTOPILOT_AVOID_WEIGHT;
                    desiredY = player.autoDirY + avoid.y * AUTOPILOT_AVOID_WEIGHT;
                }

                const mag = Math.hypot(desiredX, desiredY);
                if (mag === 0) {
                    if (!isActive) {
                        const dir = randomUnitVector();
                        desiredX = dir.x; desiredY = dir.y;
                    }
                } else {
                    desiredX /= mag; desiredY /= mag;
                }
                player.inputX = desiredX;
                player.inputY = desiredY;

                const hasSpeedBoost = isSpeedBoostActive() && speedBoostHolder === idx;
                const speedBoost = hasSpeedBoost ? SPEED_BOOST_AMOUNT : 0;
                const speedRampRounds = Math.min(roundsSurvived, SPEED_RAMP_MAX_ROUND - 1);
                const speed = PLAYER_SPEED_START + playerSpeedDelta + (isActive ? speedRampRounds * PLAYER_SPEED_PER_ROUND : 0) + speedBoost;

                player.vx += (player.inputX * speed - player.vx) * PLAYER_SMOOTHING;
                player.vy += (player.inputY * speed - player.vy) * PLAYER_SMOOTHING;

                player.x = clamp(player.x + player.vx, PLAY_AREA_PADDING, canvas.width - player.radius * 2 - PLAY_AREA_PADDING);
                player.y = clamp(player.y + player.vy, PLAY_AREA_PADDING, canvas.height - player.radius * 2 - PLAY_AREA_PADDING);
            }

            function setActivePlayer(index) {
                activeIndex = clamp(index, 0, players.length - 1);
                players.forEach((p, idx) => {
                    p.isActive = (idx === activeIndex);
                });
            }

            function eliminatePlayer(idx) {
                if (idx < 0 || idx >= players.length) return;
                const wasActive = idx === activeIndex;
                players.splice(idx, 1);

                if (speedBoostHolder === idx) { speedBoostHolder = null; speedBoostUntil = 0; }
                else if (speedBoostHolder !== null && speedBoostHolder > idx) speedBoostHolder -= 1;

                if (players.length === 0) {
                    handleLoss();
                    return;
                }

                if (wasActive) {
                    setActivePlayer(Math.min(idx, players.length - 1));
                    statusText.textContent = "Next Ball!";
                }
            }

            function isSpeedBoostActive() { return Date.now() < speedBoostUntil; }
            function isInvincibleActive() { return Date.now() < invincibleUntil; }

            function moveBlackBalls() {
                if (isGameOver || isPaused || players.length === 0) return;

                // Calculate player's current base speed (excluding powerups) to use as a cap
                const speedRampRounds = Math.min(roundsSurvived, SPEED_RAMP_MAX_ROUND - 1);
                const playerBaseSpeed = PLAYER_SPEED_START + playerSpeedDelta + (speedRampRounds * PLAYER_SPEED_PER_ROUND);

                blackBalls.forEach((ball, ballIndex) => {
                    let targetPlayer = players[0];
                    let bestDist = Infinity;
                    players.forEach(p => {
                        const d = Math.hypot(p.x - ball.x, p.y - ball.y);
                        if (d < bestDist) { bestDist = d; targetPlayer = p; }
                    });

                    const dx = targetPlayer.x - ball.x;
                    const dy = targetPlayer.y - ball.y;
                    const dist = Math.hypot(dx, dy) || 1;

                    const chaseDirX = isInvincibleActive() ? -dx : dx;
                    const chaseDirY = isInvincibleActive() ? -dy : dy;

                    let ballSpeed = BLACK_BALL_SPEED_START + enemySpeedDelta + (ballIndex * BLACK_BALL_SPEED_INCREMENT);
                    // Cap the speed
                    ballSpeed = Math.min(ballSpeed, playerBaseSpeed);

                    ball.x = clamp(ball.x + (chaseDirX / dist) * ballSpeed, PLAY_AREA_PADDING, canvas.width - ball.radius * 2 - PLAY_AREA_PADDING);
                    ball.y = clamp(ball.y + (chaseDirY / dist) * ballSpeed, PLAY_AREA_PADDING, canvas.height - ball.radius * 2 - PLAY_AREA_PADDING);

                    if (!isInvincibleActive()) {
                        for (let i = players.length - 1; i >= 0; i--) {
                            if (checkCollision(ball, players[i])) eliminatePlayer(i);
                        }
                    }
                });
            }

            // --- Rendering ---

            function drawGlow(x, y, radius, color, blur) {
                ctx.shadowBlur = blur;
                ctx.shadowColor = color;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0; // reset
            }

            function drawBall(ball, isPlayer) {
                const cx = ball.x + ball.radius;
                const cy = ball.y + ball.radius;

                // Glow
                let glowColor = ball.glowColor;
                let glowSize = 15;

                if (isPlayer) {
                    if (ball.isActive) {
                        // Pulsing effect for active player
                        const pulse = Math.sin(Date.now() / 200) * 5 + 25;
                        glowColor = 'rgba(255, 80, 80, 0.8)';
                        glowSize = pulse;
                    } else {
                        glowColor = 'rgba(255, 162, 162, 0.2)';
                        glowSize = 5;
                    }

                    if (isInvincibleActive()) {
                        glowColor = '#ffd700';
                        glowSize = 30;
                    } else if (isSpeedBoostActive() && speedBoostHolder === players.indexOf(ball)) {
                        glowColor = '#1e90ff';
                        glowSize = 30;
                    }
                }

                ctx.save();
                ctx.shadowBlur = glowSize;
                ctx.shadowColor = glowColor;

                // Gradient fill
                const grad = ctx.createRadialGradient(cx - 3, cy - 3, 2, cx, cy, ball.radius);
                if (isPlayer) {
                    if (isInvincibleActive()) {
                        grad.addColorStop(0, '#fff');
                        grad.addColorStop(1, '#ffd700');
                    } else if (isPlayer && isSpeedBoostActive() && speedBoostHolder === players.indexOf(ball)) {
                        grad.addColorStop(0, '#fff');
                        grad.addColorStop(1, '#1e90ff');
                    } else {
                        grad.addColorStop(0, '#ff9999');
                        grad.addColorStop(1, ball.isActive ? '#ff0000' : 'rgba(255, 162, 162, 0.4)');
                    }
                } else {
                    // Black ball
                    grad.addColorStop(0, '#2a3b55');
                    grad.addColorStop(1, '#0b101c');
                }

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(cx, cy, ball.radius, 0, Math.PI * 2);
                ctx.fill();

                // Border
                if (isPlayer) {
                    ctx.strokeStyle = ball.isActive ? '#fff' : 'rgba(255,255,255,0.4)';
                    ctx.lineWidth = ball.isActive ? 2 : 1;
                    if (!ball.isActive) {
                        ctx.setLineDash([2, 2]);
                    }
                    ctx.stroke();

                    // Extra ring for active player
                    if (ball.isActive) {
                        ctx.beginPath();
                        ctx.arc(cx, cy, ball.radius + 4, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }

            function drawPowerup(p) {
                const cx = p.x + p.radius;
                const cy = p.y + p.radius;

                // Pulse effect
                p.pulsePhase = (p.pulsePhase || 0) + 0.1;
                const scale = 1 + Math.sin(p.pulsePhase) * 0.1;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(scale, scale);

                ctx.shadowBlur = 15;
                ctx.shadowColor = p.color;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = p.color;
                ctx.font = "20px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(p.icon, 0, 2); // slight offset

                ctx.restore();
            }

            function render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw Powerups
                powerups.forEach(p => drawPowerup(p));

                // Draw Players
                players.forEach(p => drawBall(p, true));

                // Draw Black Balls
                blackBalls.forEach(b => drawBall(b, false));
            }

            function gameLoop() {
                if (!isGameOver && !isPaused && gameStarted) {
                    players.forEach((p, idx) => updatePlayer(p, idx === activeIndex, idx));
                    checkPowerupPickup();
                    moveBlackBalls();

                    // Update Status Text if powerups expire
                    if (!isSpeedBoostActive() && !isInvincibleActive() && statusText.textContent !== "Playing" && statusText.textContent !== "Next Ball!") {
                        statusText.textContent = "Playing";
                    }
                }

                render();
                requestAnimationFrame(gameLoop);
            }

            function startTimer() {
                clearInterval(timerInterval);
                timer = ROUND_TIME_SECONDS;
                timeRemainingEl.textContent = timer;
                timerInterval = setInterval(() => {
                    if (isGameOver || isPaused || !gameStarted) return;
                    timer -= 1;
                    timeRemainingEl.textContent = timer;
                    if (timer <= 0) nextRound();
                }, 1000);
            }

            function stopTimer() { clearInterval(timerInterval); }

            function playBeep(freq = 840, duration = 150) {
                try {
                    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    oscillator.type = "sine";
                    oscillator.frequency.value = freq;
                    gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration / 1000);
                    oscillator.connect(gain);
                    gain.connect(audioCtx.destination);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + duration / 1000);
                } catch (_) { }
            }

            function startCountdown() {
                if (isCountingDown) return;
                isCountingDown = true;
                stopTimer();

                let count = 3;
                countdownOverlay.style.display = "flex";
                countdownOverlay.textContent = count;
                playBeep();

                const tick = () => {
                    count -= 1;
                    if (count > 0) {
                        countdownOverlay.textContent = count;
                        playBeep();
                        setTimeout(tick, 1000);
                    } else {
                        countdownOverlay.textContent = "GO!";
                        playBeep(1080, 200);
                        setTimeout(() => {
                            countdownOverlay.style.display = "none";
                            isCountingDown = false;
                            startRound();
                        }, 600);
                    }
                };
                setTimeout(tick, 1000);
            }

            function startRound() {
                if (players.length === 0) players.push(createPlayer());

                isGameOver = false;
                gameStarted = true;
                statusText.textContent = "Playing";
                speedBoostUntil = 0;
                speedBoostHolder = null;
                invincibleUntil = 0;

                clearPowerups();
                clearPowerupTimer();
                keysPressed.clear();
                stopTimer();

                positionPlayersAtCenter();
                players.forEach(p => setRandomAutoDir(p));
                spawnBlackBalls(ballCount);
                spawnPowerupsForRound();

                ballCountEl.textContent = ballCount;
                setActivePlayer(Math.min(activeIndex, players.length - 1));

                startTimer();
            }

            function nextRound() {
                roundsSurvived += 1;
                ballCount += 1;
                startRound();
            }

            function resetPlayersToOne() {
                players.length = 0;
                players.push(createPlayer());
                setActivePlayer(0);
                roundsSurvived = 0;
                speedBoostHolder = null;
            }

            function handleLoss() {
                if (isGameOver) return;
                isGameOver = true;
                stopTimer();
                clearPowerupTimer();

                finalRoundsEl.textContent = roundsSurvived;
                finalDifficultyEl.textContent = DIFFICULTIES[currentDifficulty].label;

                setTimeout(() => {
                    gameOverModal.classList.add("visible");
                }, 500);
            }

            // --- Global Functions for UI ---

            window.startGame = function (difficulty) {
                const diff = DIFFICULTIES[difficulty] || DIFFICULTIES.easy;
                currentDifficulty = difficulty;
                difficultyLabel.textContent = diff.label;
                playerSpeedDelta = diff.playerSpeedDelta;
                enemySpeedDelta = diff.enemySpeedDelta;
                ballCount = diff.startBalls;
                roundsSurvived = 0;

                mainMenu.classList.remove("visible");
                hud.classList.remove("hidden");
                gameContainer.classList.remove("hidden");

                resetPlayersToOne();
                startCountdown();
            };

            window.resumeGame = function () {
                if (!gameStarted || isGameOver) return;
                isPaused = false;
                mainMenu.classList.remove("visible");
                startTimer(); // resume timer
            };

            window.restartGame = function () {
                gameOverModal.classList.remove("visible");
                mainMenu.classList.remove("visible");
                window.startGame(currentDifficulty);
            };

            window.showMainMenu = function () {
                gameOverModal.classList.remove("visible");
                mainMenu.classList.add("visible");
                resumeContainer.classList.add("hidden");
                gameStarted = false;
                isPaused = false;
                hud.classList.add("hidden");

                // Reset game state visually
                blackBalls = [];
                clearPowerups();
                players.length = 0;
                render(); // Clear canvas
            };

            function togglePause() {
                if (!gameStarted || isGameOver || isCountingDown) return;
                isPaused = !isPaused;

                if (isPaused) {
                    stopTimer();
                    mainMenu.classList.add("visible");
                    resumeContainer.classList.remove("hidden");
                } else {
                    window.resumeGame();
                }
            }

            // --- Autopilot for Verification ---
            window.enableAutopilot = function () {
                console.log("Autopilot ENABLED");
                setInterval(() => {
                    if (isGameOver || isPaused || !gameStarted) return;
                    const p = players[activeIndex];
                    if (!p) return;

                    const avoid = avoidanceInput(p);
                    // Simulate keys based on avoid vector
                    // Reset keys
                    keysPressed.clear();

                    if (avoid.x < -0.1) keysPressed.add("ArrowLeft");
                    if (avoid.x > 0.1) keysPressed.add("ArrowRight");
                    if (avoid.y < -0.1) keysPressed.add("ArrowUp");
                    if (avoid.y > 0.1) keysPressed.add("ArrowDown");

                }, 100);
            };

            // --- Initialization ---

            // Hide game elements initially
            hud.classList.add("hidden");

            // Right click pause
            document.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                togglePause();
            });

            // Start loop
            gameLoop();
        })();
    </script>
</body>

</html>